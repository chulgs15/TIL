# 서론

- 안녕하세요 이번 Docker 관련 발표를 맡게된 신철규입니다. 이번에 좋은 기술이 나와서 여러분들과 함께하는 자리를 마련하고자 진행하게되었습니다.
  - 제가 설명하고 싶은 주제는 바로 Dev/Ops와 Docker입니다. 사실 Docker 하나만 설명하려고 했지만 Docker 정의와 기술에 대한 설명은 생각보다 길지 않습니다. 또한 사용법보다는 실제 Docker가 사용되는 모습을 보여드리기 위해서 간략한 Devops와 AWS Cloud를 보여드릴 예정입니다.
  - 자, 발표를 시작하겠습니다. 결론입니다.
    - 첫번째, Docker 는 아래와 같은 장점 3가지를 가지고 있습니다.
      - 첫번째, 용량, 메모리 사용에 효율적이다.
      - 두번째, docker hub 이미지를 사용해 환경 구축에 시간 효율적이다.
      - 마지막 세번째, 도커는 운영의 배포 안정성을 보장합니다.
    - 두번째, Docker는 반드시 해야할까요? 
      - 네, 꼭 하세요. 두번 하세요. 어떤 영역에 계시더라도 하세요.
  - 시간 없으신 분들은 이제 돌아가셔도 됩니다. 이제 결론을 위한 본격적인 이야기를 해보겠습니다. 나라와 영웅에게는 탄생설화가 있듯이 Docker가 만들어진 시대적은 흐름을 먼저 보도록하시겠습니다.

# 문화와 도구의 변화.

## Waterfall

- 기존의 개발문화에 대한 설명
  ![이미지](https://www.hanumoka.net/images/20180630-weakness-of-waterfall-model_1.png)
  
  - 전통적이지만 아주 확실한 개발방법이 있습니다. 바로 Waterfall 방식이죠. 현재 CRM을 제외한 다른 프로젝트들은 Waterfall 방식으로 진행하는 것으로 알고 있습니다.
  
  - 간단히 단계를 보면, 시스템 전체의 요구사항을 정하고, 설계하고, 구현하고, 테스트하고, 이관하고 운영하는 단계를 가지고 있습니다. 
  
  - 참 명확하고 우리 뼈에 새긴 명확한 프로세스죠. 오늘 도커 설명을 위해서 일반적인 단점으로 까도록하겠습니다. 이 프로세스의 2가지 단점을 소개해드리겠습니다.
  
    - 첫번째, 현재 진행하는 단계가 끝나지 않으면, 다음 단계로 진행하지 못합니다.
  
    - 두번째, 중간에 요구사항이 바뀌면 수용하기 어렵습니다. 하지만 우리는 노동력으로 수용하고 있죠.
  
      > 노동과 채찍에 관련된 그림이 있으면 좋겠음.

## Dev/Ops
![이미지](https://miro.medium.com/max/728/0*H5SUvwGviMsyMICt.png)

* Waterfall이 소개한 단점 2가지를 가진 이유는 바로 개발의 단위가 시스템이기 때문입니다. 거대한 시스템을 한번에 만들기 위해서 각 단계별로 수많은 공수를 투입하기 때문이죠.

* 자, 반대로 제가 소개하려는 Dev/Ops 프로세스는 개발의 단위가 시스템이 아닌 모듈입니다. 모듈 하나하나를 그림과 같은 프로세스로 지속적으로 개발, 운영, 통합합니다. 

* 사전적인 정의를 아마존에서 보면

  > 서비스를 빠른 속도로 제공할 수 있도록 조직의 역량을 향상시키는 문화 철학, 방식 및 도구의 조합입니다.

- 단계를 간단하게 보시죠. Plan 부터 시작합니다. 계획을 세우고, 구현을하고, build를 하고, Test를 하고, 이관을 하고, 운영환경에 배포를 하고, 운영을 하고, 관리를하고, 다시 계획을 세웁니다.

- 특징으로는

  > DevOps 모델에서는 개발팀과 운영팀이 단일팀으로 병합되어 엔지니어가 개발에서 테스트, 배포, 운영까지 전체를 관리합니다.
  >
  > ( 김 <--> 윤 ) ( 사랑의 스튜디오 같은 그림 )
  
  - 그림만 봐도 정말 이상적인 조합 아닌가요?

* 또 다른 특징이 있습니다. Dev/Ops의 활동 중에는 속도가 느리고 수동으로 수행되던 프로세스를 자동화하는 활동이 있습니다. 그림과 같이 각 단계를 진행하기 위한 개발 도구들을 소개합니다. 도구들은 개발자가 Devops를 도와주기 위해 Support합니다. 
  ![이미지](https://blog.kakaocdn.net/dn/btzNcP/btqAXhTnbc7/2RXkMqFM9QY7nkix6LSJrK/img.png)

  * 자, 그러면 예를 들어보죠. 여러분 Test를 수동으로 하시죠. 요즘은 테스트를 위한 코드를 직접 만들고 관리합니다. 매번 요구사항을 반영하기 위해 같은 테스트를 반복하고 있죠. 하지만 요즘은 테스트는 코드로 작성해서 알아서 테스트를 진행합니다.

    > 김대원 vs 알파고

  * 그림과 같은 테스트 코드는 어느 회사의 결제 시스템에 1000 개 정도 있다고 하네요.

    > 테스트 코드 화면 캡쳐

    * 개인적으로 저 프로세스에서 우리 운영의 역할은 테스트 코드 작성과 성능관리가 될 것 같다는 생각이 듭니다.

  * 자, 다시 도구의 그림이 돌아와서...여기서 제가 소개하려는 Tool 이 2번 등장합니다. 바로 Build 와 Deploy 의 Docker 입니다.

# Docker

![도커](https://perfectacle.github.io/images/spring-boot-docker-image-optimization/thumb.png)

* 귀엽게 웃는 고래가 인상적인 이  Docker라는 시스템은 일단 무료입니다. 여러분들 맘껏 쓰셔도 됩니다. 
  
  > 와우 이건 꼭 사야해

* 이 도커란 무엇인가? 컨테이너 기반의 오픈소스 가상화 플랫폼입니다.
  *  그러면 Container란 무엇인가 격리된 공강에서 프로세스와 메모리가 동작하는 기술입니다.

    > 이건 무슨 개소리야...


![image](https://user-images.githubusercontent.com/22446581/122620738-abda8f80-d0ce-11eb-8ee9-2462a08e9b7c.png)

## 예시.

 - 너무 간단하고 어려운 설명만 했네요 쉬운 설명 들어갑니다. 
   
    - 자, 너무 어려운 설명만 했군요. 쉬운 설명 들어갑니다. 여러문 공인인증서로 이체하시죠? 처음 공인인증서로 결재하려고 하면 Internet 에 우리 정보를 훔쳐가는 보안프로그램을 설치하죠. 프로그램 하나씩 설치가 끝나면 PC나 브라우져를 재시작을 해야 합니다. 저도 PTSD 오기 시작하는데요. 
    
      > 공인인증서로 고통받는 그림
    
    - 자, 사용자는 일단 결재작업을 해야 합니다. 그렇다면 모든 보안 프로그램이 설치된 PC가 있었으면 좋겠다는 생각을하겠죠. 그래서 나온 기술이 저 VM(가상화) 기술 입니다. 보안 프로그램을 예시로 들었지만 MS 오피스, 각종 개발 Tool 이 이미 설치한 Window 는 누구나 원하실 겁니다.
    
      > 나는 완벽해....
    
    - 지금까지는 사용자의 입장이었고, 서비스 제공자의 입장에서 보시죠. 우리는 LS 일렉트릭에 서비스를 제공하고 있습니다. 예시로 EAS, 사고채권, Wels 가 있습니다. 우리는 실제 Hypervisor 기반의 VM으로 서비스를 제공하고 있습니다. 구조로만 봤을 때, 큰 단점이 보이지 않습니다.
    
      > VM 모습으로 서비스가 필요함. 각 Guest OS가 15g 사용. 라이브러리 Java + Tomcat.
### 메모리 효율

* 하지만 vm 에 단점이 있죠.
    - 각각의 VM은 Guest OS를 가지게 됩니다. 간단히 모든 VM에 Window 를 설치하죠. 자, Window 설치하면 기본용량이 15g 가까이 소모합니다. 하나의 서비스를 만드는데 15g 라면, 지금 여러 Service를 만드는데 걸리는 15 * 서비스의 갯수 만큼 기본적인 용량을 사용해야 합니다.
    
    - 자, 어찌어찌 OS 설치를 완료했습니다. 이제 예를 들었던 보안 프로그램이 설치같은 Library 설치가 있죠. 우리는 Web 서비스가 java 기반이기 때문에 java와 tomcat을 설치해야 합니다. 이런 Library는 잘 설치하면 좋은데, 만약 문제가 생기게 되면...좀 곤란한 상황이 나올 수 있습니다. VM을 다시 만들어야 할 수도 있죠.
    
    - 이제 이런 단점이 도커로 가게되면 장점이 됩니다. 첫 번째, Guest OS가 없는 경량 컨테이너 기반이기 때문에 가볍습니다. 이 가볍다는 의미는 앞서 이야기했던 용량에 해당하고, 또한 메모리도 포함합니다. 
    
      - 용량의 경우, 그림에서 보듯이 Docker 프로그램 하나에서 돌아가기 때문에 라이브러리와 어플리케이션 용량만 사용합니다.
      - 메모리도 마찬가지입니다. OS 의 기본적인 메모리를 사용하지 않기 때문에 서비스를 돌리기 위한 최소 메모리로 실행합니다. 
    
    - 두번째 장점입니다. 필요한 Library는 Docker hub 라는 저장소에서 가져오게 됩니다. 우리가 할일은 사용할 저장소와 환경변수 설정입니다.
    
      > 니가 뭘 좋아할지 몰라서 다 준비했어. (소녀시대)
    
    - 예시를 보여들까요? 우리 mysql 하나 설치해봅시다.
    
      - 설치파일로 mysql을 설치하려면, 회원가입, Intstaller 다운로드, Install, DB 생성, 계정 생성을 해아합니다.
    
      - Docker를 사용하면 아래와 같은 명령어만 실행하면 mysql을 설치하고 실행할 수 있습니다. 
    
        - 오라클 DB 도 공식적인 이미지가 아니지만 가능합니다. 
        - 이건 단순히 제 pc가 느리기 때문에 오래 걸립니다. 그래도 설치파일 작업보다는 빠릅니다. 결과는 나중에 보시도록 하시죠. 
        
        ```java
        docker run --name dev_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234567890 -d mysql:8
        ```
        
      - 이런 쉬운 설치와 실행방법 덕분에, 이번 ojdbc 이슈를 해결했었죠. 19c를 도커로 실행하고 java 로 접속 테스트를 해본 결과 java 1.5 버젼은 oracle 19c에 접속을 할수 있다는 결론을 내렸습니다.
      
        > docker 로 ojdbc 버젼별 테스트.


* 어려운 설명

  - 자, 이번에는 잠시 난이도를 높여서 Docker의 구조에 대해서 설명을 드리겠습니다. 컨테이너 기반의 오픈소스 가상화 플랫폼이라고 했습니다. Docker의 최종 결과물은 Application 이 돌아가는 Container 입니다.

  - Docker의 로고에서도 볼 수 있듯이, 고래가 컨테이너를 들고있어요. Container 는 어떻게 구성할까요?

  - 컨테이너는 사실 Docker Hub에서 다운받을 수 있는 이미지들의 집합힙니다. 자 그림을 보실까요?
    EAS 서비스가 돌아가는 Container 를 구성하기 위해서는 아래와 같은 Java 이미지와 Tomcat 이미지가 필요합니다.

    ![이미지](https://cloud.kt.com/guide/images/1568942863608.png)

    > 이미지들이 켜켜이 쌓여있는 어플리케이션. 최종 결과는 EAS 를 보여주자.

  - 이처럼 도커는 이미지들을 층층이 쌓아 올려 컨테이너를 만들고 서비스를 제공합니다. 
    하지만, 이전 그림에서 보면 컨테이터가 1개만 돌아가면 용량에 문제가 없지만, 여러 컨테이너를 만들면 그만큼 용량이 들어가는게 아닐까요? 라고 장점에 의문을 가질수 있습니다.
    ![이미지](https://cloud.kt.com/guide/images/1568942875774.png)

  - 자 아래 그림을 보시죠 OS는 Ubuntu,  Web Server 는 nginx, 그리고 Web Application 을 실행하는 컨테이너 입니다. 제가 방근 전 설명에 이미지를 층층이 쌓아 올린다고 말습드렸죠. 도커는 이걸 layer 라고 부릅니다. 이 layer 들은 동일하게 사용하는 Container 가 있다면 오직 읽기만 가능한 이미지로 다른 Container 에서 사용이 가능합니다. 이런 재사용성 때문에 용량 문제를 줄일 수 있습니다.

    > 이미지를 공유해서 사용하는 Docker container.  
    
  - 즉, Docker 는 아래와 같은 구조를 가지고 있습니다.
  
    ![이미지](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcToeosf30RjOgAhVoeJhyIrS2FIrvIQviNemA&usqp=CAU)

* 자 이제 이번 발표의 하이라이트입니다. 개발자가 도커를 사용하는 가장 큰 장점은 바로 이것입니다.

  > 도커는 배포의 안정성을 보장한다.
  >
  > Local PC에서 도커로 실행 = 운영환경에서 도커로 실행
  * 도커는 운영 배포의 안정성을 보장합니다. 이게 무슨말이냐 하면 여러분 PC 에서 도커로 만든 프로그램이 문제가 없다면, 운영환경에서 문제가 없습니다.

    * 정말 문제가 없는건 아니고, 정확히는 소스코드와 라이브러리 일광성을 보장합니다.

  * 자, 개발 단계와 배포 단계의 오류가 있습니다. 어느쪽이 더 해결하기 어려울까요? 배포 단계의 오류는 정말 약도 없죠. 소차장님 PTSD 한번 볼까요?

    ```sql
    select 1 from daul
    ```

    

  * 네, Partner Portal의 유명한 사건이죠. DB 접속확인을 위한 SQL이 개발에서는 dual 이었지만, 운영에서는 daul로 바뀐 사건이죠. TA, IT팀, SM이 밤을 새며 찾았던 문제로 기억합니다.

    * 자, Docker에 관점에서 봤을 때 이런 문제는 Container 에서 발생할 수 없는 문제입니다. 

      > 라스베거스에서는 상상도 할 수 없는 문제야.

  * 왜? 개발한 컨테이너가 운영환경에서 그대로 실행할 테니까요. 빌드한 이미지가 Docker Hub에 등록하고 운영환경은 이런 이미지를 가져와서 그대로 Container로 실행합니다.
  
    > build > push > pull > exec

​    

* 자 이 정도 봤으면, 예제 소스 한번 봐야죠. 여러분들을 위해서 미리 준비해왔어요

  > 여러분들을 위해 만들어왔어요.
  >
  > 프로그램 구조
  * frontend는 WEB 프레임워크인 Angular, backend는 java 기반의 spring boot, DB 는 amazon cloud rds의 mysql을 사용했습니다.

  * 구현한 기능은 아래와 같습니다. hello world 라는 버튼을 클릭하면 backend까지 연결을 확인합니다. id, password를 입력하면 backend와 db 연결까지 확인할 수 있습니다.

    > 기능을 간략하게 설명한 예시 한장

  * 그리고, 우리가 방금전에 dev/ops 프로세스를 보여드렸죠. 이 그림과 연결해서 구현할 내용을 보여드립니다.

    > dev/ops 와 내 툴을 합친 그림.

    * plan은 우리가 기능을 구현할 내용을 보였드렸고, code는 intellij 개발과 github로 형상관리합니다., build 는 Docker입니다. test 는 frontend와 backend의 테스트 자동화 프로그램이 있지만 이번에는 넘어가겠습니다. release 는 travis ci 를 사용합니다. 배포를 자동화하는 프로그램인데 ERP 로 따지면 pgmsync 자동화 버젼이라고 생각하시면 됩니다. deploy 또한 docker 와 aws cloud에 올릴 예정입니다.  

* 시연은 크게 3가지를 보여드릴 겁니다. 

  1. Docker 로 실행하는 모습,
  2. 수정 후 다시 docker로 빌드 및 시작
  3. Github push > travis ci 자동 docker build 와 aws 이관 > aws는 docker container를 실행.

* Docker 로 실행하는 모습니다.
  * Docker는 설정파일인 dockerfile과 multi container를 실행할 수 있는 docker-compose.yml 을 반드시 만드셔야 합니다. 
  * 자, 간단히 backend의 dockerfile을 보시면 이렇게 생겼습니다. 간단히 흐름만 설명드리면 maven 컨테이너에서 spring boot 를 build 합니다. build한 결과물을 jre 이미지로 가져와 container 로 실행합니다.
  * 자 실행해 봅시다.
* 우리 기능한번 추가해 볼까요? 간단히 페이지의 문서를 수정해보죠.
* 자 결과를 확인해보죠. 
  * docker-compose 로 확인.
  * 이제 github 에 최신소스로 반영하고, 반영한 내용을 travis-ci 가 자동으로 감지해서 aws 로 배포할 겁니다.
* 이 작업이 좀 걸려서 중간에 질문 받겠습니다. 궁금하신 점 있으면 질문해주세요.
  * 그리고 결과 확인.

# 결론

* 결론입니다. 

  * Docker는 이런 장점을 가지고 있습니다.

    * 용량, 메모리 사용에 효율적이다.
    * docker hub 이미지를 사용해 환경 구축에 시간 효율적이다.
    * 이 2가지 장점은 잊으셔도 됩니다. 왜냐? 이건 제가 구조를 설명하기 위한 마이너한 장점이기 때문입니다.
    * 다 필요없고, 도커는 운영의 배포 안정성을 보장합니다. 이 점이 중요합니다. 
      * 방금전에 보셨듯이 local 의 docker 결과와 운영의 docker 결과가 동일하다는 것을 알게되었습니다.

  * Docker는 반드시 해야하나요?

    * 네, 무조건 하세요.

      > 묻고 더블로 가.

    * 제가 java 하라는 이야기는 안합니다. 근데 docker는 하셔야 합니다. 왜? 현재 이 기술을 대체할 상위 기술이 없습니다. 언젠가는 나올 수 있지만, 현재 Docker 는 이미 시장에서 너무 영향력이 커서 docker을 무시하고 발표할 수 없습니다.

    * Web 기술 stack을 간단히 보시면, 몇몇 기술은 대체제가 없는데 배포에 있어서는...없어요. 

* 마무리입니다.

  * 사실 이해를 위해서 많은 좋은 기능을 제외하고 설명을 드렸습니다. 이번 기회로 여러분들이 docker에 관심을 가지셨으면 좋겠다는 생각을 하며 저도 정리할 겸 여러분들에게 짧게 소개를 드렸습니다. docker 사용법을 익히시는데 별로 어렵지 않습니다. 꼭 배우시길 바라며, 다른 좋은 기술이 있다면 여러분들에게 설명하지는 기회를 가지도록 노력해보겠습니다. 감사합니다.



# 참고

- https://brunch.co.kr/@fits-b/2
  - DEVOPS 의 단점?
- https://www.44bits.io/ko/post/why-should-i-use-docker-container
  - 눈송이 서버
- https://cloud.kt.com/portal/user-guide/education-eduadvanced-edu_adv_2
  - layer

 

