

- 내가 이야기 하려는 주제는 무엇인가?

  - Docker 란 무엇인가?
  - Cloud로 운영하는 방식 소개

    - Dev/Ops 와 연결해서 설명해보는 건 어떨까?
  
- 기존의 개발문화에 대한 설명

  ![이미지](https://www.hanumoka.net/images/20180630-weakness-of-waterfall-model_1.png)

  - 기존 워터폴 방식을 설명하면서 문제점을 설명한다.
    - 우리는 기존 워터폴 방삭으로 개발을 진행했습니다. 요구사항 수립, 설계, 구현, 테스트, 이관 및 운영. 이런 5가지 단계로 서비스를 구현합니다.
    - 이 문제점은 현재 진행하는 단계가 완성되지 않으면 다음 단계로 진행하지 못하며, 중간에 요구사항 변경을 받아드리기 어렵다는 점이 있습니다.

- 정의

  ![이미지](https://miro.medium.com/max/728/0*H5SUvwGviMsyMICt.png)

    - 출처: <https://aws.amazon.com/ko/devops/what-is-devops/> 
  - 서비스를 빠른 속도로 제공할 수 있도록 조직의 역량을 향상시키는 문화 철학, 방식 및 도구의 조합입니다.
  - DevOps 모델에서는 개발팀과 운영팀이 단일팀으로 병합되어 엔지니어가 개발에서 테스트, 배포, 운영까지 전체를 관리합니다.
  - 기존 워터폴의 단점인 모든 단계 Step by     Step 으로 확인과 요구사항 확장의 불가능을 저 흐름에 맞게 

- 단계

  - 단계에 대한 설명과 예시가 필요하네.

    - 만약 쇼핑몰 서비스를 구축한다고 생각해볼까요? 어떤 서비스를 만들지 설계하고, 설계대로 코드를 작성합니다. 작성한 코드를 빌드해서 문법문제가 없는지 확인하고 Test 를 진행합니다. Test에 성공한 빌드는 운영환경에 전달하는       Release/Deploy를 진행합니다. 자, 이제 운영자는 모니터링을 하면서 이슈나 문제점을 찾습니다. 
    - 이슈와 문제점을 개선하기 위해 새로운 설계를 진행하며 다시 Dev/Ops  프로세스를 시작합니다.

  - DevOps 방식을 사용하여 속도가 느리고 수동으로 수행되던 프로세스를 자동화

    - 여러 단계가 있지만 자동화 영역은 뭐가 있을까요
      - BUILD, TEST,  RELEASE, DEPLOY, MONITOR

    - 반대로 비자동화 영역은

      - PLAN, OPREATE,  CODE

  - 이중 Docker는 BUILD, DEPLOY를 담당합니다.

    ![이미지](https://blog.kakaocdn.net/dn/btzNcP/btqAXhTnbc7/2RXkMqFM9QY7nkix6LSJrK/img.png)

    - 그림 필요.

- Docker

  ![image](https://user-images.githubusercontent.com/22446581/122620738-abda8f80-d0ce-11eb-8ee9-2462a08e9b7c.png)

  - 정의
    - 컨테이너 기반의 오픈소스 가상화 플랫폼.

  - 컨테이너란?

    - 격리된 공간에서 프로세스가 동작하는 기술.
    - 컨테이너 > 이미지  > Layer
      - heiarchy 를 그려야 겠네

  - 쉬운 설명

    - 자, 너무 어려운 설명만 했군요. 쉬운 설명 들어갑니다. 여러문 공인인증서로 이체하시죠? 처음 공인인증서로 결재하려고 하면 Internet 에 우리 정보를 훔쳐가는 보안프로그램을 설치하죠. 프로그램 하나씩 설치가 끝나면 PC나 브라우져를 재시작을 해야 합니다. 저도 PTSD 오기 시작하는데요. 

    - 자, 사용자는 일단 결재작업을 해야 합니다. 그렇다면 모든 보안 프로그램이 설치된 PC가 있었으면 좋겠다는 생각을하겠죠. 그래서 나온 기술이 저 VM(가상화) 기술 입니다. 보안 프로그램을 예시로 들었지만 MS 오피스, 각종 개발 Tool 이 이미 설치한 Window 는 누구나 원하실 겁니다.

    - 지금까지는 사용자의 입장이었고, 서비스 제공자의 입장에서 보시죠. 우리는 LS 일렉트릭에 서비스를 제공하고 있습니다. 예시로 EAS, 사고채권, Wels 가 있습니다. 우리는 실제 Hypervisor 기반의 VM으로 서비스를 제공하고 있습니다. 구조로만 봤을 때, 큰 단점이 보이지 않습니다.

      > VM 모습으로 서비스가 필요함. 각 Guest OS가 15g 사용. 라이브러리 Java + Tomcat.

    - 이제 상세하게 단점을 까보죠. 각각의 VM은 Guest OS를 가지게 됩니다. 간단히 모든 VM에 Window 를 설치하죠. 자, Window 설치하면 기본용량이 15g 가까이 소모합니다. 하나의 서비스를 만드는데 15g 라면, 지금 여러 Service를 만드는데 걸리는 15 * 서비스의 갯수 만큼 기본적인 용량을 사용해야 합니다.

    - 자, 어찌어찌 OS 설치를 완료했습니다. 이제 예를 들었던 보안 프로그램이 설치같은 Library 설치가 있죠. 우리는 Web 서비스가 java 기반이기 때문에 java와 tomcat을 설치해야 합니다. 이런 Library는 잘 설치하면 좋은데, 만약 문제가 생기게 되면...좀 곤란한 상황이 나올 수 있습니다. VM을 다시 만들어야 할 수도 있죠.

    - 이제 이런 단점이 도커로 가게되면 장점이 됩니다. 첫 번째, OS 가 없는 경량 컨테이너 기반이기 때문에 가볍습니다. 이 가볍다는 의미는 앞서 이야기했던 용량에 해당하고, 또한 메모리도 포함합니다. 

      - 용량의 경우, 그림에서 보듯이 Docker 프로그램 하나에서 돌아가기 때문에 라이브러리와 어플리케이션 용량만 사용합니다.
      - 메모리도 마찬가지입니다. OS 의 기본적인 메모리를 사용하지 않기 때문에 서비스를 돌리기 위한 최소 메모리로 실행합니다. 

    - 자, 또 다른 장점입니다. 필요한 Library는 Docker hub 라는 저장소에서 가져오게 됩니다. 우리가 할일은 사용할 저장소와 환경변수 설정입니다.

      > 니가 뭘 좋아할지 몰라서 다 준비했어.

    - 예시를 보여들까요? 우리 mysql 하나 설치해봅시다.

      - 설치파일로 mysql을 설치하려면, 회원가입, Intstaller 다운로드, Install, DB 생성, 계정 생성을 해아합니다.

      - Docker를 사용하면 아래와 같은 명령어만 실행하면 mysql을 설치하고 실행할 수 있습니다.

        ```
        docker 명령어 + 명령어 설명.
        ```

        
      
      - 이건 단순히 제 pc가 느리기 때문에 오래 걸립니다. 그래도 설치파일 작업보다는 빠릅니다. 결과는 나중에 보시도록 하시죠.
      
      - 이런 쉬운 설치와 실행방법 덕분에, 이번 ojdbc 이슈를 해결했었죠. 19c를 도커로 실행하고 java 로 접속을 테스트 해봅니다.
      
        > Oracle 19c ojdbcX.jar 연결 그림

- 어려운 설명

  - 자, 이번에는 잠시 난이도를 높여서 Docker의 구죠에 대해서 설명을 드리겠습니다. 컨테이너 기반의 오픈소스 가상화 플랫폼이라고 했습니다. Docker의 최종 결과물은 Application 이 돌아가는 Container 입니다.

  - Docker의 로고에서도 볼 수 있듯이, 고래가 컨테이너를 들고있어요. Container 는 어떻게 구성할까요?

  - 컨테이너는 사실 Docker Hub에서 다운받을 수 있는 이미지들의 집합힙니다. 자 그림을 보실까요?
    EAS 서비스가 돌아가는 Container 를 구성하기 위해서는 아래와 같은 Java 이미지와 Tomcat 이미지가 필요합니다.

    ![이미지](https://cloud.kt.com/guide/images/1568942863608.png)

    > 이미지들이 켜켜이 쌓여있는 어플리케이션. 최종 결과는 EAS 를 보여주자.

  - 이처럼 도커는 이미지들을 층층이 쌓아 올려 컨테이너를 만들고 서비스를 제공합니다. 
    하지만, 이전 그림에서 보면 컨테이터가 1개만 돌아가면 용량에 문제가 없지만, 여러 컨테이너를 만들면 그만큼 용량이 들어가는게 아닐까요? 라고 장점에 의문을 가질수 있습니다.
    ![이미지](https://cloud.kt.com/guide/images/1568942875774.png)

  - 자 아래 그림을 보시죠 OS는 Ubuntu,  Web Server 는 nginx, 그리고 Web Application 을 실행하는 컨테이너 입니다. 제가 방근 전 설명에 이미지를 층층이 쌓아 올린다고 말습드렸죠. 도커는 이걸 layer 라고 부릅니다. 이 layer 들은 동일하게 사용하는 Container 가 있다면 오직 읽기만 가능한 이미지로 다른 Container 에서 사용이 가능합니다. 이런 재사용성 때문에 용량 문제를 줄일 수 있습니다.

    > 이미지를 공유해서 사용하는 Docker container.  



* 자 이제 이번 발표의 하이라이트입니다. 개발자가 도커를 사용하는 가장 큰 장점은 바로 이것입니다.

  > 도커는 운영 배포의 안정성을 보장한다.
  >
  > Local PC에서 도커로 실행 = 운영환경에서 도커로 실행
  * 도커는 운영 배포의 안정성을 보장합니다. 이게 무슨말이냐 하면 여러분 PC 에서 도커로 만든 프로그램이 문제가 없다면, 운영환경에서 문제가 없습니다.

    * 정말 문제가 없는건 아니고, 정확히는 소스코드와 라이브러리 일광성을 보장합니다.

  * 자, 개발 단계와 배포 단계의 오류가 있습니다. 어느쪽이 더 해결하기 어려울까요? 배포 단계의 오류는 정말 약도 없죠. 소차장님 PTSD 한번 볼까요?

    ```sql
    select 1 from daul
    ```

    

  * 네, Partner Portal의 유명한 사건이죠. DB 접속확인을 위한 SQL이 개발에서는 dual 이었지만, 운영에서는 daul로 바뀐 사건이죠. TA, IT팀, SM이 밤을 새며 찾았던 문제로 기억합니다.

    * 자, Docker에 관점에서 봤을 때 이런 문제는 Container 에서 발생할 수 없는 문제입니다. 

      > 라스베거스에서는 상상도 할 수 없는 문제야.

  * 왜? 개발한 컨테이너가 운영환경에서 그대로 실행할 테니까요. 빌드한 이미지가 Docker Hub에 등록하고 운영환경은 이런 이미지를 가져와서 그대로 Container로 실행합니다.
  
    > build > push > pull > exec
  

​    

* 자 이 정도 봤으면, 예제 소스 한번 봐야죠. 여러분들을 위해서 미리 준비해왔어요

  > 프로그램 구조
  * frontend는 WEB 프레임워크인 Angular, backend는 java 기반의 spring boot, DB 는 amazon cloud rds의 mysql을 사용했습니다.

  * 구현한 기능은 아래와 같습니다. hello world 라는 버튼을 클릭하면 backend까지 연결을 확인합니다. id, password를 입력하면 backend와 db 연결까지 확인할 수 있습니다.

    > 기능을 간략하게 설명한 예시 한장

  * 그리고, 우리가 방금전에 dev/ops 프로세스를 보여드렸죠. 이 그림과 연결해서 구현할 내용을 보여드립니다.

    > dev/ops 와 내 툴을 합친 그림.

    * plan은 우리가 기능을 구현할 내용을 보였드렸고, code는 intellij 개발과 github로 형상관리합니다., build 는 Docker입니다. test 는 frontend와 backend의 테스트 자동화 프로그램이 있지만 이번에는 넘어가겠습니다. release 는 travis ci 를 사용합니다. 배포를 자동화하는 프로그램인데 ERP 로 따지면 pgmsync 자동화 버젼이라고 생각하시면 됩니다. deploy 또한 docker 와 aws cloud에 올릴 예정입니다.  

* 시연은 크게 3가지를 보여드릴 겁니다. 

  1. Docker 로 실행하는 모습,
  2. 수정 후 다시 docker로 빌드 및 시작
  3. Github push > travis ci 자동 docker build 와 aws 이관 > aws는 docker container를 실행.

* Docker 로 실행하는 모습니다.
  * Docker는 설정파일인 dockerfile과 multi container를 실행할 수 있는 docker-compose.yml 을 반드시 만드셔야 합니다. 
  * 자, 간단히 backend의 dockerfile을 보시면 이렇게 생겼습니다. 간단히 흐름만 설명드리면 maven으로 spring boot 를 build 하고 build한 결과물을 jre 이미지로 가져와 container 로 실행합니다.
  * 자 실행해 봅시다.
* 우리 기능한번 추가해 볼까요? 간단히 페이지의 문서를 수정해보죠.
* 자 결과를 확인해보죠. 
  * docker-compose 로 확인.
  * 이제 github 에 최신소스로 반영하고, 반영한 내용을 travis-ci 가 자동으로 감지해서 aws 로 배포할 겁니다.
* 이 작업이 좀 걸려서 중간에 질문 받겠습니다. 궁금하신 점 있으면 질문해주세요.
  * 그리고 결과 확인.

# 결론

* 결론입니다. 

  * Docker는 이런 장점을 가지고 있습니다.

    * 용량, 메모리 사용에 효율적이다.
    * docker hub 이미지를 사용해 환경 구축에 시간 효율적이다.
    * 이 2가지 장점은 잊으셔도 됩니다. 왜냐? 이건 제가 구조를 설명하기 위한 마이너한 장점이기 때문입니다.
    * 다 필요없고, 도커는 운영의 배포 안정성을 보장합니다. 이 점이 중요합니다. 
      * 방금전에 보셨듯이 local 의 docker 결과와 운영의 docker 결과가 동일하다는 것을 알게되었습니다.

  * Docker는 반드시 해야하나요?

    * 네, 무조건 하세요.

      > 묻고 더블로 가.

    * 제가 java 하라는 이야기는 안합니다. 근데 docker는 하셔야 합니다. 왜? 현재 이 기술을 대체할 상위 기술이 없습니다. 언젠가는 나올 수 있지만, 현재 Docker 는 이미 시장에서 너무 영향력이 커서 docker을 무시하고 발표할 수 없습니다.

    * Web 기술 stack을 간단히 보시면, 몇몇 기술은 대체제가 없는데 배포에 있어서는...없어요. 

* 마무리입니다.

  * 사실 이해를 위해서 많은 좋은 기능을 제외하고 설명을 드렸습니다. 이번 기회로 여러분들이 docker에 관심을 가지셨으면 좋겠다는 생각을 하며 저도 정리할 겸 여러분들에게 짧게 소개를 드렸습니다. docker 사용법을 익히시는데 별로 어렵지 않습니다. 꼭 배우시길 바라며, 다른 좋은 기술이 있다면 여러분들에게 설명하지는 기회를 가지도록 노력해보겠습니다. 감사합니다.





- 아키텍쳐 + AWS + Beanstalk + RDS

  - 위 그림에 맞는 내 프로그램이 필요하네.

- Frontend
- Backend
- AWS Beanstalk
- RDS
- 시연

  - 새로운 서비스를 만들 필요가 있음
  - Frontend 수정
  - Backend 수정
  - docker compose 
  - Github push
  - Travis CI
  - AWS Beanstalk 진행.
  - 결과 확인.
- 참고

  - https://brunch.co.kr/@fits-b/2
    - DEVOPS 의 단점?
  - https://www.44bits.io/ko/post/why-should-i-use-docker-container
    - 눈송이 서버
  - https://cloud.kt.com/portal/user-guide/education-eduadvanced-edu_adv_2
    - layer

 

 

* 문화
* 개발
* 시현

 
