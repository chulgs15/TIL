# 시스템

* 복잡성은 죽음이다. 개발에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.
* 도시를 새운다면?
  * 관심의 분야가 거시와 미시가 있기 때문에, 큰 시스템은 체계적으로 움직일 수 있다.
  * 시스템 수전에서 깨끗함을 유지하는 방법을 살펴본다.
* 시스템 제작과 시스템 사용을 분리하라.
  * 제작은 사용과 아주 다르다.
  * 애플리케이션의 시작단계에서 중요한 점은 관심사의 분리다.
  * 초기화 지연 혹은 계산 지연
    * 생성자 인수를 명시적으로 의존문제.
    * 테스트 문제
    * 모든 상황에 적합한 객체 여부.
  * 체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대로 안된다.
    * 의존성을 연결할 때 일반 실행 논리와 분리해야 모듈성이 높아진다.
    * 일관성 있는 방식을 사용하자.
* Main 분리
  * 시스템 생성과 사용을 분리하는 방법.
    * 생성과 관련된 코드는 모두 main 이나 main이 호출하는 모듈로 옮기자.
  * 팩토리
    * 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.
      * 이렇게 되려면...LineItemFactory가 Singleton 이 되어야 하는게 아닐까?
        아니면,,,인자값으로 넘겨주던가?
  * 의존성 주입
    * 사용과 제작을 분리하는 강력한 매커니즘
    * 초기하ㅗ 지연과 계산 지연의 장점도 차용.
* 확장.
  * 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신이다. 
  * 소프트웨어 시스템은 수명이 짧다.는 본질로 인해 아키텍쳐의 점진적인 발전이 가능하다.
  * 확장성에 실패한 예시로 EJB 소스를 소개.
  * 횡단 감심사
    * AOP에서 관점이라는 모듈 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다." 라고 명시한다.
* 대표적인 자바 AOP 예제.
  * 자바 프록시
    * 구현하려면 InvocationHandler를 사용한다. 굉장히 코드 양이 많고 복잡하다.
  * 순수 자바 AOP 프로엠 워크
    * 스프링 AOP, JBOSS AOP 등과 같은 프록시를 지원하는 프레임워크가 있다.
    * 프로그래머는 설정 파일이나 API를 사용해 필수적인 애플리케이션 기반 구조를 구현한다.
    * Spring 예제.
      * xml 과 java 코드를 완전히 분리했다?
      * xml 도 읽기 쉽지 않은데...
  * AspectJ 관점.
    * 뭐...있다 정도만...
* 테스트 주도 세스템 아키텍쳐 구축.
  * 아주 단순하면서도 멋지게 분리된 아키텍쳐로 소프트웨어를 출시 후, 기반 구조를 추가하며 조금씩 확장해 나가도 괜찮다는 말이다.
    * 변하는 환경에 대처해 진로를 변경할 능력도 반드시 유지해야 한다. 
* 의사결정을 최적화하라
* 명백한 가치가 있을 때 표준을 현명하게 사용하라.
* 시스템은 도메인 특화 언어가 필요하다.